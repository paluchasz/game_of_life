# Game of Life Project [2018]
In this project we have an infinite two dimensional grid of cells which are either dead or alive. With each iteration the cells are either born or they die (both happen simultaneously) depending on the number of neighbouring alive cells (If less than 2 or more than 3 near an alive cell cell dies, otherwise lives on, if exactly 3 alive ones near a dead cell, the cell becomes alive). 

### My approach

I initially created a single Game of Life class which will take an object, board, which is a 2D array of 1s and 0s where a 1 represents an alive cell and 0 a dead cell. I would then be able to use this instance variable (not class variable! - see below) in methods throughout the class. I started off just focusing on cell death to start off with. I did not even see how I was going to represent the board yet. I tried to represent it with printing like |_| but then I couldn’t figure out how I would combine that and how I would place an ‘o’ above the _. 
So I just worked with 1s and 0s to start off with. I saw that there would be a problem with edge cases due to the index being out of range so I just decided to focus on the middle. 

At this point I realised that I will probably need a copy of my board so that if I loop through the board and kill a cell in one position it is not going to affect another position as a result. Here I learnt that by assigning temp_board = self.board does not actually copy the board. After I altered self.board temp_board changed too because they both point to the same location in memory. The solution was to import copy, and use deepcopy() to copy the board. Next I sorted out the edge cases. Initially, I thought I did not have to treat the first row and column separately as it was not giving an error but as it turned out arr[negative number] starts taking elements from the end of the array. So in the end I had nine separate cases – the four edges, four corners and the rest with a lot of repeating code but at least it worked. 
I then finally tackled the issue of representing the board. I googled for some ideas and initially saw the Turtle library but I thought it might still be quite involved. Instead I found the Python Imaging Library (PIL). It did not take long to learn how to draw lines and spheres. Then after drawing the grid I just had to loop through and create a sphere for each alive cell (each 1). 
Now I was ready to tackle cell creation and possible expansion of the board. I first wrote a method which will expand the board by creating an extra layer of zeros and a method with checked if the board needs to be expanded (if there a 3 alive cells in a row on the edge). I then called these methods (very important to use self.method() otherwise it doesn’t work!) in my iteration method and worked out a way to not have to loop through the board again but check cell death and cell creation at the same time. Finally, I created a main play the game method which will call the iteration and draw board method as many times as the number of iterations. 
So I now had working code but with PIL each board image was shown in a different window which appeared all at once and the only way I could see to make it better was to have a time.wait() function which would give some time between opening the next iteration image. At this point I finally realised that you can just use square brackets to draw the board with prints so I did that in another file which looked much neater. But in total I had 300 lines of code so now I spoke to my friend Felix about making my code better…
Code corrections: I could cut out almost half the code by being a bit clever. By making sure I always have an extra layer of dead cells around my board I can afford not to look at the edge cases so my iteration function is no longer repetitive. (Later I spotted a bug and actually had to make sure that I am adding an extra layer of zeros if any of the two outer edges have a 1). I also made the code much more readable by giving better names to the methods, creating more methods and calling them within the iteration method, putting the main play the game method at the top of the class, and  adding a lot of comments. 
I also created another file which draws the board with Matplotlib.

## Things learnt in this project:
  
  * To copy an object use deepcopy(), merely assigning it to another variable doesn’t create a copy as they point to the same place in memory
  * A lot about classes! Firstly the self.board I defined in the constructor is actually an instance variable (or instance attribute), not a class variable (or class attribute). 
  * “Class variables are variables that are being shared with all instances (objects) which were created using that particular class. So when accessed a class variable from any instance, the value will be same. Instance variables on the other hand are variables, which all instances keep for themselves (i.e a particular object owns its instance variables). So typically values of instance variables differ from instance to instance.” 
  * A class variable would be defined just after class definition and outside of all methods. Instance variables should be defined within methods. Class variables are useful for storing constants or defining default values.
  * All the methods with self in it are instance methods. This is what I am used to.
  * A class method would have cls. We can access class methods without even instantiating the object. e.g. we could have a class SomeClass() with a class method class_method(cls) and we can access this immediately with SomeClass.class_method().
  * The self word remembers which instance of the class you are referring too. That’s why when you are calling a method you do not input anything for the parameter self. For example, we can do: obj1 = SomeClass(), obj1.method(6) and python will translate it to something like SomeClass.method(obj1, 6).
  * Use self.method() to call an instance method in another instance method. I guess for class methods this would not be necessary to do cls.method(). 

Ref: https://medium.com/quick-code/understanding-self-in-python-a3704319e5f0
Some more insights and detail can be found here: https://www.toptal.com/python/python-class-attributes-an-overly-thorough-guide
